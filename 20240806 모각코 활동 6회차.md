오늘의목표 CNN 실습 - MNIST 이미지 분류
(RESNET은 7회차에 진행할 예정)

```
import torch #pytorch 가져오기
```

```
#데이터셋불러오고 텐서로 바꿔주기

from torchvision import datasets #데이터셋 불러오고

from torchvision.transforms import ToTensor #텐서로 바꿔주기

  

#datasets에서 MNIST 가져와서 훈련데이터와 테스트데이터 가져와주기.

#datasets.MNIST(root - 데이터가 저장될 경로, train - train이 true 이면 train data이고 false면 test data, download - 데이터 없으면 인터넷에서 다운로드해줌 , transform - transform을 ToTensor로 지정해주지 않으면 텐서의 형식이 아닌, PIL이미지로 데이터가 가져와지게 된다, target_transform)

  

train_data = datasets.MNIST(

    root = "data",

    train = True, #train data를 다운로드

    transform = ToTensor(),

    download = True

)

test_data = datasets.MNIST(

    root = 'data',

    train = False, #test data를 다운로드

    transform = ToTensor()

)
```

```
#학습데이터 확인

print(train_data)

print(train_data.data.size())

# 데이터셋의 이름은 MNIST

# 데이터의 수는 60000개

# 훈련데이터

# StandardTransform(데이터셋에 일관되게 적용되는 변환의 표준을 정의) -> Transform: ToTensor() #이미지 데이터들을 모두 일관되게 텐서 형태로 변환하겠다는 것을 의미.


#테스트데이터 확인

print(test_data)

print(test_data.data.size())

#데이터의 수가 10000 인 것과 테스트데이터라는 것을 제외하면 나머지 속성은 학습데이터와 동일함.
```

```
#데이터 시각적으로 확인

import matplotlib.pyplot as plt #시각적 확인을 위해 matplotlib을 사용.

fig, ax = plt.subplots() #fig와 ax는 plt.subplot()으로 쓰일 것.

ax.imshow(train_data.data[0], cmap='gray')

  

for i in range(train_data.data[0].shape[0]):

  for j in range(train_data.data[0].shape[1]):

    c = 1 if train_data.data[0][i, j].item() < 125 else 0

    ax.text(j, i, str(train_data.data[0][i, j].item()), color=(c, c, c), ha='center', va='center', fontsize=5)

  

plt.title("%i" % train_data.targets[0])

plt.show
```
![mnist_1](https://ejkiwi.github.io/lib/media/MNIST.png)

```
from torch.utils.data import DataLoader

loaders = {

    'train' : torch.utils.data.DataLoader(train_data,

                                          batch_size=100,

                                          shuffle=True,

                                          num_workers=1),

    'test' : torch.utils.data.DataLoader(test_data,

                                         batch_size=100,

                                         shuffle=True,

                                         num_workers=1)

}

loaders
```

```
class CNN(torch.nn.Module):

  

  def __init__(self):

    super(CNN, self).__init__()

    self.layer1 = torch.nn.Sequential(

        torch.nn.Conv2d(1, 16, kernel_size=5, stride=1, padding=2), #컨볼루션 레이어(합성곱층) #1차원 데이터를 받아 16개의 feature로 나누겟다!!임.

        torch.nn.ReLU(), #ReLU층

        torch.nn.MaxPool2d(kernel_size=2, stride=2)) #풀링층

    self.layer2 = torch.nn.Sequential(

        torch.nn.Conv2d(16, 32, kernel_size=5, stride=1, padding=2),

        torch.nn.ReLU(),

        torch.nn.MaxPool2d(kernel_size=2, stride=2))

    self.fc = torch.nn.Linear(32 * 7 * 7, 10, bias=True) #32*7*7만큼의 입력을 linear레이어에 의해 계산되게 해서... 10개의 출력이 나오도록 함.

    torch.nn.init.xavier_uniform_(self.fc.weight)

    # __init__에서 정의내린 레이어들을

    # 아래 forward(얘가 실제적인 모델의 형태가 됨)에서 사용한다.

  

  def forward(self, x): #순전파

    out = self.layer1(x)

    out = self.layer2(out)

    out = out.view(out.size(0), -1)

    out = self.fc(out)

    return out
```

```
model = CNN()

model
```
CNN(
  (layer1): Sequential(
    (0): Conv2d(1, 16, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))
    (1): ReLU()
    (2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (layer2): Sequential(
    (0): Conv2d(16, 32, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))
    (1): ReLU()
    (2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (fc): Linear(in_features=1568, out_features=10, bias=True)
)

---

```
learning_rate = 0.01

loss_func = torch.nn.CrossEntropyLoss()

optimizer =  torch.optim.Adam(model.parameters(), lr=learning_rate)

training_epochs = 10
```

```
total_batch = len(loaders['train'])

for epoch in range(training_epochs):

  avg_cost = 0

  

  for X, Y in loaders['train']:

    optimizer.zero_grad()

    pred = model(X) #순전파

    cost = loss_func(pred, Y) #손실함수계산

    cost.backward() #역전파

    optimizer.step()

  

    avg_cost += cost / total_batch

  

  print('[Epoch: {:>4}] cost = {:>.9}'.format(epoch + 1, avg_cost))

  # print('[Epoch: ', epoch + 1, ']  ','cost = ', avg_cost)

print('Learning Finished....>_<')
```
[Epoch: 1] cost = 0.0461711548
[Epoch: 2] cost = 0.0472225286
[Epoch: 3] cost = 0.0413064063
[Epoch: 4] cost = 0.0417594947
[Epoch: 5] cost = 0.0395734794
[Epoch: 6] cost = 0.0441303253
[Epoch: 7] cost = 0.0408433564
[Epoch: 8] cost = 0.043582622
[Epoch: 9] cost = 0.0441764817
[Epoch: 10] cost = 0.0412645154
Learning Finished....>_<